/*
    Copyright 2009,2010 Daniel Zerbino (zerbino@ebi.ac.uk)

    This file is part of Oases.

    Oases is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    Oases is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Oases. If not, see <http://www.gnu.org/licenses/>.
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "run.h"
#include "transcript.h"

static void printUsage()
{
	puts("Usage:");
	puts("./oases directory [options]");
	puts("");
	puts("\tdirectory\t\t\t: working directory name");
	puts("");
	puts("Standard options:");
	puts("\t-min_pair_count <integer>\t: minimum number of paired end connections to justify the scaffolding of two long contigs (default: 10)");
	puts("\t-ins_length2 <integer>\t\t: expected distance between two paired-end reads in the second short-read dataset (default: no read pairing)");
	puts("\t-ins_length_long <integer>\t: expected distance between two long paired-end reads (default: no read pairing)");
	puts("\t-ins_length*_sd <integer>\t: est. standard deviation of respective dataset (default: 10\% of corresponding length)");
	puts("\t\t[replace '*' by nothing, '2' or '_long' as necessary]");
	puts("\t-cov_cutoff <floating-point|auto>\t: removal of low coverage nodes AFTER tour bus or allow the system to infer it");
	puts("\t--help\t\t\t\t: this help message");
	puts("");
	puts("Output:");
	puts("\tdirectory/highly_expressed_transcripts.fa");
	puts("\tdirectory/plausible_transcripts.fa");
	puts("\tdirectory/splicing_events.txt");
}

int main(int argc, char **argv)
{
	Graph *graph;
	char *directory, *graphFilename, *seqFilename, *transcriptFilename,
	    *eventFilename;
	Coordinate insertLength[CATEGORIES];
	Coordinate insertLengthLong = -1;
	Coordinate std_dev[CATEGORIES];
	Coordinate std_dev_long = -1;
	FILE *file;
	int arg_index, arg_int;
	char *arg;
	Category cat;
	long long longlong_var;
	short int short_var;
	Locus *loci;
	IDnum locusCount;
	ReadSet *reads;
	Coordinate *lengths;
	double coverageCutoff = -1;
	boolean *dubious = NULL;

	setProgramName("oases");

	for (cat = 0; cat < CATEGORIES; cat++) {
		insertLength[cat] = -1;
		std_dev[cat] = -1;
	}

	// Error message
	if (argc == 1) {
		puts("oases - De novo transcriptome assembler for the Velvet package");
		printf("Version %i.%i.%2.2i\n", VERSION_NUMBER,
		       RELEASE_NUMBER, UPDATE_NUMBER);
		puts("\nCopyright 2007, 2008 Daniel Zerbino (zerbino@ebi.ac.uk)");
		puts("This is free software; see the source for copying conditions.  There is NO");
		puts("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
		puts("Compilation settings:");
		printf("CATEGORIES = %i\n", CATEGORIES);
		printf("MAXKMERLENGTH = %i\n", MAXKMERLENGTH);
		puts("");
		printUsage();
		return 1;
	}

	if (strcmp(argv[1], "--help") == 0) {
		printUsage();
		return 0;
	}
	// Memory allocation 
	directory = argv[1];
	graphFilename = mallocOrExit(strlen(directory) + 100, char);
	seqFilename = mallocOrExit(strlen(directory) + 100, char);
	transcriptFilename = mallocOrExit(strlen(directory) + 100, char);
	eventFilename = mallocOrExit(strlen(directory) + 100, char);

	// Argument parsing
	for (arg_index = 2; arg_index < argc; arg_index++) {
		arg = argv[arg_index++];
		if (arg_index >= argc) {
			puts("Unusual number of arguments!");
			printUsage();
			exit(1);
		}
		if (strcmp(arg, "-cov_cutoff") == 0) {
			sscanf(argv[arg_index], "%lf", &coverageCutoff);
		} else if (strcmp(arg, "-min_pair_count") == 0) {
			sscanf(argv[arg_index], "%i", &arg_int);
			setUnreliableConnectionCutoff_oases(arg_int);
		} else if (strcmp(arg, "--help") == 0) {
			printUsage();
			return 0;
		} else if (strcmp(arg, "-ins_length") == 0) {
			sscanf(argv[arg_index], "%lli", &longlong_var);
			insertLength[0] = (Coordinate) longlong_var;
			if (insertLength[0] < 0) {
				printf("Invalid insert length: %lli\n",
				       (long long) insertLength[0]);
				exit(1);
			}
		} else if (strcmp(arg, "-ins_length_sd") == 0) {
			sscanf(argv[arg_index], "%lli", &longlong_var);
			std_dev[0] = (Coordinate) longlong_var;
			if (std_dev[0] < 0) {
				printf("Invalid std deviation: %lli\n",
				       (long long) std_dev[0]);
				exit(1);
			}
		} else if (strcmp(arg, "-ins_length_long") == 0) {
			sscanf(argv[arg_index], "%lli", &longlong_var);
			insertLengthLong = (Coordinate) longlong_var;
		} else if (strcmp(arg, "-ins_length_long_sd") == 0) {
			sscanf(argv[arg_index], "%lli", &longlong_var);
			std_dev_long = (Coordinate) longlong_var;
		} else if (strncmp(arg, "-ins_length", 11) == 0
			   && strchr(arg, 'd') == NULL) {
			sscanf(arg, "-ins_length%hi", &short_var);
			cat = (Category) short_var;
			if (cat < 1 || cat > CATEGORIES) {
				printf("Unknown option: %s\n", arg);
				exit(1);
			}
			sscanf(argv[arg_index], "%lli", &longlong_var);
			insertLength[cat - 1] = (Coordinate) longlong_var;
			if (insertLength[cat - 1] < 0) {
				printf("Invalid insert length: %lli\n",
				       (long long) insertLength[cat - 1]);
				exit(1);
			}
		} else if (strncmp(arg, "-ins_length", 11) == 0) {
			sscanf(arg, "-ins_length%hi_sd", &short_var);
			cat = (Category) short_var;
			if (cat < 1 || cat > CATEGORIES) {
				printf("Unknown option: %s\n", arg);
				exit(1);
			}
			sscanf(argv[arg_index], "%lli", &longlong_var);
			std_dev[cat - 1] = (Coordinate) longlong_var;
			if (std_dev[cat - 1] < 0) {
				printf("Invalid std deviation: %lli\n",
				       (long long) std_dev[cat - 1]);
				exit(1);
			}
		} else {
			printf("Unknown option: %s;\n", arg);
			printUsage();
			return 1;
		}
	}

	// Bookkeeping
	logInstructions(argc, argv, directory);

	strcpy(seqFilename, directory);
	strcat(seqFilename, "/Sequences");

	strcpy(graphFilename, directory);
	strcat(graphFilename, "/Graph2");

	// Graph uploading or creation
	if ((file = fopen(graphFilename, "r")) != NULL) {
		fclose(file);
		strcpy(graphFilename, directory);
		strcat(graphFilename, "/Graph2");
		graph = importGraph(graphFilename);
		reads =
		    importEmptyReadSet(seqFilename, &lengths,
				       getWordLength(graph));
	} else {
		puts("No Graph2 file to work with!");
		puts("Please re-run Velvetg with the -read_trkg option on.");
		return 1;
	}

	dubious =
	    removeLowCoverageNodesAndDenounceDubiousReads(graph,
							  coverageCutoff);
	clipTipsHard(graph);

	// Set insert lengths and their standard deviations
	createReadPairingArray(reads);
	for (cat = 0; cat < CATEGORIES; cat++) {
		if (insertLength[cat] > -1 && std_dev[cat] < 0)
			std_dev[cat] = insertLength[cat] / 10;
		setInsertLengths(graph, cat,
				 insertLength[cat], std_dev[cat]);
		if (insertLength[cat] > -1) {
			pairUpReads(reads, 2 * cat + 1);
		}

		detachDubiousReads(reads, dubious);
	}

	if (insertLengthLong > -1 && std_dev_long < 0)
		std_dev_long = insertLengthLong / 10;
	setInsertLengths(graph, CATEGORIES, insertLengthLong,
			 std_dev_long);
	if (insertLengthLong > -1)
		pairUpReads(reads, 2 * CATEGORIES + 1);

	loci =
	    extractGraphLoci(graph, reads, dubious, lengths, &locusCount);

	computeHighlyExpressedTranscripts(loci, locusCount);
	strcpy(transcriptFilename, directory);
	strcat(transcriptFilename, "/highly_expressed_transcripts.fa");
	exportTranscripts(loci, locusCount, transcriptFilename);
	strcpy(transcriptFilename, directory);
	strcat(transcriptFilename,
	       "/contig-ordering-highly-expressed.txt");
	exportContigOrders(loci, locusCount, transcriptFilename);
	cleanTranscriptMemory(loci, locusCount);

	removeIndirectConnections();
	computePlausibleTranscripts(loci, locusCount);
	strcpy(transcriptFilename, directory);
	strcat(transcriptFilename, "/plausible_transcripts.fa");
	exportTranscripts(loci, locusCount, transcriptFilename);
	strcpy(transcriptFilename, directory);
	strcat(transcriptFilename, "/contig-ordering-plausible.txt");
	exportContigOrders(loci, locusCount, transcriptFilename);
	cleanTranscriptMemory(loci, locusCount);

	computeASEvents(loci, locusCount);
	strcpy(eventFilename, directory);
	strcat(eventFilename, "/splicing_events.txt");
	exportASEvents(loci, locusCount, eventFilename);

	cleanLocusMemory(loci, locusCount);
	destroyGraph(graph);
	free(graphFilename);
	free(seqFilename);
	free(transcriptFilename);
	free(eventFilename);
	free(dubious);
	destroyReadSet(reads);
	return 0;
}
